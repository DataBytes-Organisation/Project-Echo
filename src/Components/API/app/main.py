import os
# from Components.API.app.routers import add_csv_output_option, audio_upload_router
from .routers import add_csv_output_option, audio_upload_router

from fastapi import FastAPI, Body, HTTPException, status, APIRouter, Request
from fastapi.middleware.cors import CORSMiddleware
from app.routers import species_predictor
from app.routers import auth_router
from fastapi.responses import Response, JSONResponse
from fastapi.encoders import jsonable_encoder
from pydantic import BaseModel, Field, EmailStr
from bson import ObjectId
from typing import Optional, List
import datetime
import pymongo
import json 


# from .routers import hmi, engine, sim
app = FastAPI()

# Add the CORS middleware

from app.routers import hmi, engine, sim, two_factor
app = FastAPI()




from app.routers import hmi, engine, sim, iot

# ✅ Add metadata here
app = FastAPI(
    title="Project Echo API",
    description="""
    Project Echo is an IoT-based system designed to record and analyze audio data for species identification and ecosystem monitoring.

    This API provides endpoints to:
    - Upload audio files
    - Simulate audio responses
    - Interface with HMI and audio engine modules
    """,
    version="1.0.0"
)

# ✅ CORS Middleware
app.add_middleware(
    CORSMiddleware,
    allow_origins=["*"],  # Allow all origins
    allow_credentials=True,
    allow_methods=["*"],
    allow_headers=["*"],
)


# app.include_router(hmi.router, tags=['hmi'], prefix='/hmi')
# app.include_router(engine.router, tags=['engine'], prefix='/engine')
# app.include_router(sim.router, tags=['sim'], prefix='/sim')
# app.include_router(add_csv_output_option.router, tags=['csv'], prefix='/api')
app.include_router(audio_upload_router.router, tags=['audio'], prefix='/api')


# ✅ Include routers
app.include_router(hmi.router, tags=['hmi'], prefix='/hmi')
app.include_router(engine.router, tags=['engine'], prefix='/engine')
app.include_router(sim.router, tags=['sim'], prefix='/sim')
app.include_router(two_factor.router)

app.include_router(iot.router, tags=['iot'], prefix='/iot')
app.include_router(species_predictor.router, tags=["predict"])



# ✅ Root endpoint
@app.get("/", response_description="API Root")
def show_home():
    return 'Welcome to echo api, move to /docs for more'
    return 'Welcome to Project Echo API. Visit /docs for interactive documentation.'

app.include_router(auth_router.router, tags=["auth"], prefix="/api")

# ✅ /openapi-export - fetch live OpenAPI spec
@app.get("/openapi-export", include_in_schema=False)
async def get_openapi_spec():
    """
    Returns the current OpenAPI spec generated by FastAPI.
    Used for downloading and converting to YAML.
    """
    return app.openapi()

# ✅ /spec/summary - for OpenAPI spec verification/debug
@app.get("/spec/summary", tags=["debug"], include_in_schema=False)
async def get_spec_summary():
    """
    Returns a summary of the OpenAPI spec for deployment verification.
    """
    spec = app.openapi()
    return {
        "title": spec.get("info", {}).get("title"),
        "version": spec.get("info", {}).get("version"),
        "number_of_paths": len(spec.get("paths", {})),
        "tags": [tag.get("name") for tag in spec.get("tags", []) if "name" in tag]
    }

# ✅ Save OpenAPI spec to file when app starts
def export_openapi_to_file():
    """
    Saves the OpenAPI spec to a file on startup.
    Creates the 'backend' folder if it doesn't exist.
    """
    output_dir = "backend"
    os.makedirs(output_dir, exist_ok=True)  # creates the folder if it doesn't exist
    output_path = os.path.join(output_dir, "project-echo-openapi.json")

    with open(output_path, "w") as f:
        json.dump(app.openapi(), f, indent=2)

    print(f"✅ OpenAPI spec exported to {output_path}")

export_openapi_to_file()

# Global error handlers
@app.exception_handler(HTTPException)
async def http_exception_handler(request: Request, exc: HTTPException):
    return JSONResponse(status_code=exc.status_code, content={
        "error": {
            "type": "http_error",
            "message": exc.detail if isinstance(exc.detail, str) else str(exc.detail),
            "status_code": exc.status_code,
            "path": str(request.url),
        }
    })

@app.exception_handler(Exception)
async def unhandled_exception_handler(request: Request, exc: Exception):
    return JSONResponse(status_code=500, content={
        "error": {
            "type": "server_error",
            "message": "Internal server error",
            "status_code": 500,
            "path": str(request.url),
        }
    })

# API versioning alias (v1) — keeps legacy routes while exposing versioned ones
try:
    from app.routers import species_predictor, audio_upload_router
    v1_api = APIRouter(prefix="/api/v1")
    # Including existing routers under v1 prefix. Note: their internal paths may already include /api/*
    v1_api.include_router(species_predictor.router, tags=["predict"])  # exposes /api/v1/predict
    v1_api.include_router(audio_upload_router.router, tags=["audio"])  # exposes /api/v1/api/audio/upload
    app.include_router(v1_api)
except Exception:
    # If routers are not available at import time, skip v1 mounting
    pass

# --- Health & Readiness Endpoints ---
from functools import lru_cache
from time import time

START_TIME = time()

@app.get("/health", include_in_schema=False)
@app.get("/healthz", include_in_schema=False)
def health():
    """Basic liveness endpoint."""
    return {"status": "ok", "uptime_seconds": int(time() - START_TIME)}

@lru_cache(maxsize=1)
def _mongo_client():
    uri = os.getenv("MONGODB_URI") or os.getenv("USER_MONGODB_URI")
    if not uri:
        return None
    try:
        client = pymongo.MongoClient(uri, serverSelectionTimeoutMS=800)
        return client
    except Exception:
        return None

@app.get("/readyz", include_in_schema=False)
def ready():
    """Readiness: validates dependencies (Mongo if configured)."""
    checks = {}
    mongo_ok = True
    client = _mongo_client()
    if client:
        try:
            client.admin.command("ping")
        except Exception:
            mongo_ok = False
    else:
        # If no URI configured we don't fail readiness—treated as optional.
        mongo_ok = True
    checks["mongo"] = mongo_ok
    overall = all(checks.values())
    status_code = 200 if overall else 503
    return JSONResponse(status_code=status_code, content={"ready": overall, "checks": checks})

